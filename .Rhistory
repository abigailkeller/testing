model_data <- moddat[[1]]
inits <- moddat[[2]]
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
cov =  NULL
family = 'negbin'
p10priors = c(1,20)
q = TRUE
phipriors = NULL
multicore = FALSE
initial_values = inits
n.chain = 1
n.iter.burn = 100
n.iter.sample = 75
thin = 1
adapt_delta = 0.9
verbose = TRUE
seed = NULL
# moddat <- get_model_data(data,cov,family,p10priors,q,phipriors,
#                          multicore,initial_values,n.chain,n.iter.burn,
#                          n.iter.sample,thin,adapt_delta,verbose,seed)
moddat <- get_model_data_trad(data, family,q,phipriors,multicore,
initial_values,n.chain,n.iter.burn,
n.iter.sample,thin,adapt_delta,
verbose, seed)
inits
initial_values
## 13.
# model includes 'q','phi' (traditional model)
# constants
nsite <- 20
nobs_count <- 100
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
phi <- 1.2
q <- 2
# traditional type
count_type <- cbind(matrix(1, nrow = nsite, ncol = nobs_count/2),
matrix(2, nrow = nsite, ncol = nobs_count/2))
# count
count <- matrix(NA, nrow = nsite, ncol = nobs_count)
for(i in 1:nsite){
for(j in 1:nobs_count){
if(count_type[i,j]==1){
count[i,j] <- rnbinom(n = 1, mu = mu[i], size = phi)
} else {
count[i,j] <- rnbinom(n = 1, mu = mu[i]*q, size = phi)
}
}
}
# collect data
data <- list(
count = count,
count.type = count_type
)
# initial values
inits <- list()
inits[[1]] <- list(
mu = mu,
phi = phi
)
names(inits[[1]]) <- c('mu','phi')
cov =  NULL
family = 'negbin'
p10priors = c(1,20)
q = TRUE
phipriors = NULL
multicore = FALSE
initial_values = inits
n.chain = 1
n.iter.burn = 100
n.iter.sample = 75
thin = 1
adapt_delta = 0.9
verbose = TRUE
seed = NULL
# moddat <- get_model_data(data,cov,family,p10priors,q,phipriors,
#                          multicore,initial_values,n.chain,n.iter.burn,
#                          n.iter.sample,thin,adapt_delta,verbose,seed)
moddat <- get_model_data_trad(data, family,q,phipriors,multicore,
initial_values,n.chain,n.iter.burn,
n.iter.sample,thin,adapt_delta,
verbose, seed)
model_data <- moddat[[1]]
inits <- moddat[[2]]
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q'))$summary
model <- rstan::stan_model('inst/stan/traditional_count.stan')
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q'))$summary
test <- rstan::summary(out)$summary
View(test)
model <- rstan::stan_model('inst/stan/traditional_count.stan')
model <- rstan::stan_model('inst/stan/traditional_count.stan')
model <- rstan::stan_model('inst/stan/traditional_count.stan')
model <- rstan::stan_model('inst/stan/traditional_count.stan')
model <- rstan::stan_model('inst/stan/traditional_count.stan')
model <- rstan::stan_model('inst/stan/traditional_count.stan')
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q'))$summary
model_data$ctch
model_data$nparams
model <- rstan::stan_model('inst/stan/traditional_count.stan')
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q'))$summary
model <- rstan::stan_model('inst/stan/traditional_count.stan')
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q'))$summary
model <- rstan::stan_model('inst/stan/traditional_count.stan')
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q'))$summary
model <- rstan::stan_model('inst/stan/traditional_count.stan')
model <- rstan::stan_model('inst/stan/traditional_count.stan')
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
test <- rstan::summary(out)$summary
View(test)
model <- rstan::stan_model('inst/stan/traditional_continuous.stan')
# constants
nsite <- 20
nobs_count <- 100
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
q <- 2
beta_gamma <- 1
alpha_gamma <- mu * beta_gamma
# traditional type
count_type <- cbind(matrix(1, nrow = nsite, ncol = nobs_count/2),
matrix(2, nrow = nsite, ncol = nobs_count/2))
# collect data
data <- list(
count = count,
count.type = count_type
)
# initial values
inits <- list()
inits[[1]] <- list(
alpha = mu,
beta = rep(1,length(mu)),
q = q
)
names(inits[[1]]) <- c('alpha','beta','q')
cov =  NULL
family = 'gamma'
p10priors = c(1,20)
q = TRUE
phipriors = NULL
multicore = FALSE
initial_values = inits
n.chain = 1
n.iter.burn = 100
n.iter.sample = 75
thin = 1
adapt_delta = 0.9
verbose = TRUE
seed = NULL
# moddat <- get_model_data(data,cov,family,p10priors,q,phipriors,
#                          multicore,initial_values,n.chain,n.iter.burn,
#                          n.iter.sample,thin,adapt_delta,verbose,seed)
moddat <- get_model_data_trad(data, family,q,phipriors,multicore,
initial_values,n.chain,n.iter.burn,
n.iter.sample,thin,adapt_delta,
verbose, seed)
model_data <- moddat[[1]]
inits <- moddat[[2]]
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q'))$summary
test <- rstan::summary(out)$summary
View(test)
model <- rstan::stan_model('inst/stan/joint_continuous.stan')
model <- rstan::stan_model('inst/stan/joint_continuous.stan')
model <- rstan::stan_model('inst/stan/joint_continuous.stan')
# constants
nsite <- 20
nobs_count <- 100
nobs_pcr <- 8
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
beta <- 0.5
log_p10 <- -4.5
q <- 2
beta_gamma <- 1
alpha_gamma <- mu * beta_gamma
# traditional type
count_type <- cbind(matrix(1, nrow = nsite, ncol = nobs_count/2),
matrix(2, nrow = nsite, ncol = nobs_count/2))
# count
count <- matrix(NA, nrow = nsite, ncol = nobs_count)
for(i in 1:nsite){
for(j in 1:nobs_count){
if(count_type[i,j]==1){
count[i,j] <- rgamma(1,shape = alpha_gamma[i],rate = beta_gamma)
} else {
count[i,j] <- rgamma(1,shape = alpha_gamma[i]*q,rate = beta_gamma)
}
}
}
# p11 (probability of true positive eDNA detection) and p (probability
# of eDNA detection)
p11 <- rep(NA,nsite)
p <- rep(NA,nsite)
for (i in 1:nsite){
p11[i] <- mu[i] / (mu[i] + exp(beta))
p[i] <- min(p11[i] + exp(log_p10),1)
}
# qPCR.N (# qPCR observations)
qPCR.N <- matrix(NA, nrow = nsite, ncol = nobs_pcr)
for(i in 1:nsite){
qPCR.N[i,] <- rep(3,nobs_pcr)
}
# qPCR.K (# positive qPCR detections)
qPCR.K <- matrix(NA, nrow = nsite, ncol = nobs_pcr)
for (i in 1:nsite){
qPCR.K[i,] <- rbinom(nobs_pcr, qPCR.N[i,], rep(p[i],nobs_pcr))
}
# collect data
data <- list(
qPCR.N = qPCR.N,
qPCR.K = qPCR.K,
count = count,
count.type = count_type
)
# initial values
inits <- list()
inits[[1]] <- list(
alpha_gamma = mu,
beta_gamma = rep(1,length(mu)),
p10 = exp(log_p10),
alpha = beta,
q = q
)
names(inits[[1]]) <- c('alpha_gamma','beta_gamma','p10','alpha','q')
source('../get_model_data.R')
source('../jointModel_helper.R')
cov =  NULL
family = 'gamma'
p10priors = c(1,20)
q = TRUE
phipriors = NULL
multicore = FALSE
initial_values = inits
n.chain = 1
n.iter.burn = 100
n.iter.sample = 75
thin = 1
adapt_delta = 0.9
verbose = TRUE
seed = NULL
moddat <- get_model_data(data,cov,family,p10priors,q,phipriors,
multicore,initial_values,n.chain,n.iter.burn,
n.iter.sample,thin,adapt_delta,verbose,seed)
# moddat <- get_model_data_trad(data, family,q,phipriors,multicore,
#                                           initial_values,n.chain,n.iter.burn,
#                                           n.iter.sample,thin,adapt_delta,
#                                           verbose, seed)
model_data <- moddat[[1]]
inits <- moddat[[2]]
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q','p11_trad'))$summary
model <- rstan::stan_model('inst/stan/joint_count.stan')
## 2.
# model includes 'p10','beta','q'
# constants
nsite <- 20
nobs_count <- 100
nobs_pcr <- 8
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
beta <- 0.5
log_p10 <- -4.5
q <- 2
# traditional type
count_type <- cbind(matrix(1, nrow = nsite, ncol = nobs_count/2),
matrix(2, nrow = nsite, ncol = nobs_count/2))
# count
count <- matrix(NA, nrow = nsite, ncol = nobs_count)
for(i in 1:nsite){
for(j in 1:nobs_count){
if(count_type[i,j]==1){
count[i,j] <- rpois(1, mu[i])
} else {
count[i,j] <- rpois(1, mu[i]*q)
}
}
}
# p11 (probability of true positive eDNA detection) and p (probability
# of eDNA detection)
p11 <- rep(NA,nsite)
p <- rep(NA,nsite)
for (i in 1:nsite){
p11[i] <- mu[i] / (mu[i] + exp(beta))
p[i] <- min(p11[i] + exp(log_p10),1)
}
# qPCR.N (# qPCR observations)
qPCR.N <- matrix(NA, nrow = nsite, ncol = nobs_pcr)
for(i in 1:nsite){
qPCR.N[i,] <- rep(3,nobs_pcr)
}
# qPCR.K (# positive qPCR detections)
qPCR.K <- matrix(NA, nrow = nsite, ncol = nobs_pcr)
for (i in 1:nsite){
qPCR.K[i,] <- rbinom(nobs_pcr, qPCR.N[i,], rep(p[i], nobs_pcr))
}
# collect data
data <- list(
qPCR.N = qPCR.N,
qPCR.K = qPCR.K,
count = count,
count.type = count_type
)
# initial values
inits <- list()
inits[[1]] <- list(
mu = mu,
p10 = exp(log_p10),
alpha = beta,
q = q
)
names(inits[[1]]) <- c('mu','p10','alpha','q')
cov =  NULL
family = 'poisson'
p10priors = c(1,20)
q = TRUE
phipriors = NULL
multicore = FALSE
initial_values = inits
n.chain = 1
n.iter.burn = 100
n.iter.sample = 75
thin = 1
adapt_delta = 0.9
verbose = TRUE
seed = NULL
moddat <- get_model_data(data,cov,family,p10priors,q,phipriors,
multicore,initial_values,n.chain,n.iter.burn,
n.iter.sample,thin,adapt_delta,verbose,seed)
# moddat <- get_model_data_trad(data, family,q,phipriors,multicore,
#                                           initial_values,n.chain,n.iter.burn,
#                                           n.iter.sample,thin,adapt_delta,
#                                           verbose, seed)
model_data <- moddat[[1]]
inits <- moddat[[2]]
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(out,pars=c('mu','q','p11_trad'))$summary
model <- rstan::stan_model('inst/stan/joint_count.stan')
model <- rstan::stan_model('inst/stan/joint_count.stan')
model <- rstan::stan_model('inst/stan/joint_count.stan')
model <- rstan::stan_model('inst/stan/joint_count.stan')
model <- rstan::stan_model('inst/stan/joint_continuous.stan')
