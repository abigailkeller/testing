expect_error(mu_critical(model1$model),
paste0("If model_fit contains site-level covariates, values ",
"must be provided for cov_val"))
#5. cov_val is numeric, if provided
expect_error(mu_critical(model1$model, cov_val = c(TRUE, TRUE)),
"cov_val must be a numeric vector")
#6. Only include input cov_val if covariates are included in model
expect_error(mu_critical(model3$model, cov_val = c(0, 0)),
paste0("cov_val must be NULL if the model does not ",
"contain site-level covariates."))
#7. Only include input cov_val if covariates are included in model
expect_error(mu_critical(model1$model, cov_val = c(0, 0, 0)),
paste0("cov_val must be of the same length as the number of ",
"non-intercept site-level coefficients in the model."))
#' @srrstats {G5.2,G5.2b,BS2.15} Tests the assure function input checks are
#'   behaving as expected.
#1. input tags are valid, q = TRUE
expect_error(traditional_model(data = list(Count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 2, NA))),
q = TRUE,
multicore = FALSE),
"Data should include 'count' and 'count_type'.")
#2. input tags are valid, q = FALSE
expect_error(traditional_model(data = list(Count = rbind(c(4, 1, 1),
c(1, 1, NA))),
multicore = FALSE),
"Data should include 'count'.")
#3. make sure dimensions of count and count_type are equal, if count_type is
# present
#' @srrstats {BS2.1a} Test to ensure pre-processing routines to ensure all
#'   input data is dimensionally commensurate
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2),
c(1, 2))),
q = TRUE,
multicore = FALSE),
"Dimensions of count and count_type do not match.")
#4. make sure all data is numeric -- if q == TRUE
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c("NA", 2, 2),
c(1, 2, 2))),
q = TRUE,
multicore = FALSE),
"Data should be numeric.")
#5. make sure all data is numeric -- if q == FALSE
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, "NA"))),
multicore = FALSE),
"Data should be numeric.")
#6. make sure locations of NAs in count data match locations of NAs in
# count_type data
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(NA, 2, 2),
c(1, 2, 2))),
q = TRUE,
multicore = FALSE),
paste0("Empty data cells \\(NA\\) in count data should match ",
"empty data cells \\(NA\\) in count_type data."))
#7. make sure family is either 'poisson', 'negbin', or 'gamma'
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA))),
family = "normal",
multicore = FALSE),
paste0("Invalid family. Options include 'poisson', ",
"'negbin', or 'gamma'."))
#8. the smallest count_type is 1
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(0, 1, 2),
c(1, 2, NA))),
q = TRUE,
multicore = FALSE),
paste0("The first gear type should be referenced as 1 in ",
"count_type. Subsequent gear types should be ",
"referenced 2, 3, 4, etc."))
#9. count are integers
expect_error(traditional_model(data = list(count = rbind(c(4.1, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 1, 2),
c(1, 2, NA))),
q = TRUE, family = "negbin",
multicore  = FALSE),
paste0("All values in count should be non-negative integers. ",
"Use family = 'gamma' if count is continuous."))
#10. count_type are integers
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1.1, 1, 2),
c(1, 2, NA))),
q = TRUE,
multicore = FALSE),
"All values in count_type should be integers.")
#11. phi priors is a vector of two numeric values
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA))),
phi_priors = c(0, 1), family = "negbin",
multicore = FALSE),
paste0("phi_priors should be a vector of two positive ",
"numeric values. ex. c\\(0.25,0.25\\)"))
#12. make sure no column is entirely NA in count
expect_error(traditional_model(data = list(count = rbind(c(4, 1, NA),
c(1, 1, NA))),
multicore = FALSE),
"count contains a column with all NA.")
#13. make sure no data are undefined
expect_error(traditional_model(data = list(count = rbind(c(4, 1, Inf),
c(1, 1, NA))),
multicore = FALSE),
"count contains undefined values \\(i.e., Inf or -Inf\\)")
#14. length of initial values is equal to the number of chains
n_chain <- 4
inits <- list()
for (i in 1:n_chain) {
inits[[i]] <- list(
mu <- stats::runif(2, 0, 1)
)
names(inits[[i]]) <- c("mu")
}
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA))),
n_chain = 5, initial_values = inits,
multicore = FALSE),
paste0("The length of the list of initial values should equal ",
"the number of chains \\(n_chain, default is 4\\)."))
#15. initial values check mu length
n_chain <- 4
inits <- list()
for (i in 1:n_chain) {
inits[[i]] <- list(
mu <- stats::runif(3, 0, 1)
)
names(inits[[i]]) <- c("mu")
}
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA))),
initial_values = inits,
multicore = FALSE),
paste0("The length of initial values for 'mu' should ",
"equal the number of sites."))
#16. initial values check mu is positive numeric
n_chain <- 4
inits <- list()
for (i in 1:n_chain) {
inits[[i]] <- list(
mu <- stats::runif(3, -1, 0)
)
names(inits[[i]]) <- c("mu")
}
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA))),
initial_values = inits,
multicore = FALSE),
"Initial values for 'mu' should be numeric values > 0.")
#17. initial values check q
n_chain <- 4
inits <- list()
for (i in 1:n_chain) {
inits[[i]] <- list(
q <- c(0.1, 0.1)
)
names(inits[[i]]) <- c("q")
}
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 1, 2),
c(1, 2, NA))),
initial_values = inits,
multicore = FALSE),
paste0("The length of initial values for 'q' should equal: ",
"\\# unique gear types \\- 1 \\(i.e., q for reference ",
"type = 1\\)."))
#18. check length and range of n_chain
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
n_chain = c(1, 1), multicore = FALSE),
paste0("n_chain should be an integer > 0 and of length 1."))
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
n_chain = 0, multicore = FALSE),
paste0("n_chain should be an integer > 0 and of length 1."))
#19. check length and range of n_iter
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
n_iter = c(1, 1), multicore = FALSE),
paste0("n_iter should be an integer > 0 and of length 1."))
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
n_iter = 0, multicore = FALSE),
paste0("n_iter should be an integer > 0 and of length 1."))
#20. check length and range of n_warmup
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
n_warmup = c(1, 1), multicore = FALSE),
"n_warmup should be an integer > 0 and of length 1.")
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
n_warmup = 0, multicore = FALSE),
"n_warmup should be an integer > 0 and of length 1.")
#21. check length and range of thin
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
thin = c(1, 1), multicore = FALSE),
"thin should be an integer > 0 and of length 1.")
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
thin = 0, multicore = FALSE),
"thin should be an integer > 0 and of length 1.")
#22. check length and range of adapt_delta
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
adapt_delta = c(0.9, 0.9), multicore = FALSE),
paste0("adapt_delta should be a numeric value > 0 and < 1 and ",
"of length 1."))
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
adapt_delta = 1.2, multicore = FALSE),
paste0("adapt_delta should be a numeric value > 0 and < 1 and ",
"of length 1."))
#23. check length of seed
expect_error(traditional_model(data = list(count = rbind(c(4, 1, 1),
c(1, 1, NA)),
count_type = rbind(c(1, 2, 1),
c(1, 1, NA))),
seed = c(1, 2), multicore = FALSE),
"seed should be an integer of length 1.")
devtools::install()
# constants
nsite <- 20
nobs_count <- 100
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
q <- 2
beta_gamma <- 1
alpha_gamma <- mu * beta_gamma
# traditional type
count_type <- cbind(matrix(1, nrow = nsite, ncol = nobs_count / 2),
matrix(2, nrow = nsite, ncol = nobs_count / 2))
# collect data
data <- list(
count = count,
count_type = count_type
)
# initial values
inits <- list()
# constants
nsite <- 20
nobs_count <- 100
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
q <- 2
beta_gamma <- 1
alpha_gamma <- mu * beta_gamma
# count
for (i in 1:nsite) {
for (j in 1:nobs_count) {
if (count_type[i, j] == 1) {
count[i, j] <- rgamma(1, shape = alpha_gamma[i],
rate = beta_gamma)
} else {
count[i, j] <- rgamma(1, shape = alpha_gamma[i] * q,
rate = beta_gamma)
}
}
}
# count
count <- matrix(NA, nrow = nsite, ncol = nobs_count)
for (i in 1:nsite) {
for (j in 1:nobs_count) {
if (count_type[i, j] == 1) {
count[i, j] <- rgamma(1, shape = alpha_gamma[i],
rate = beta_gamma)
} else {
count[i, j] <- rgamma(1, shape = alpha_gamma[i] * q,
rate = beta_gamma)
}
}
}
# traditional type
count_type <- cbind(matrix(1, nrow = nsite, ncol = nobs_count / 2),
matrix(2, nrow = nsite, ncol = nobs_count / 2))
# collect data
data <- list(
count = count,
count_type = count_type
)
# initial values
inits <- list()
inits[[1]] <- list(
alpha = mu,
beta = rep(1, length(mu)),
q = q
)
names(inits[[1]]) <- c("alpha", "beta", "q")
# run model
fit <- suppressWarnings({
traditional_model(data = data, q = TRUE, family = "gamma",
n_chain = 1, multicore = FALSE, seed = 10,
initial_values = inits, n_warmup = 25, n_iter = 100)
})
devtools::load_all()
devtools::load_all()
# constants
nsite <- 20
nobs_count <- 100
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
q <- 2
beta_gamma <- 1
alpha_gamma <- mu * beta_gamma
# count
count <- matrix(NA, nrow = nsite, ncol = nobs_count)
for (i in 1:nsite) {
for (j in 1:nobs_count) {
if (count_type[i, j] == 1) {
count[i, j] <- rgamma(1, shape = alpha_gamma[i],
rate = beta_gamma)
} else {
count[i, j] <- rgamma(1, shape = alpha_gamma[i] * q,
rate = beta_gamma)
}
}
}
# traditional type
count_type <- cbind(matrix(1, nrow = nsite, ncol = nobs_count / 2),
matrix(2, nrow = nsite, ncol = nobs_count / 2))
# count
count <- matrix(NA, nrow = nsite, ncol = nobs_count)
for (i in 1:nsite) {
for (j in 1:nobs_count) {
if (count_type[i, j] == 1) {
count[i, j] <- rgamma(1, shape = alpha_gamma[i],
rate = beta_gamma)
} else {
count[i, j] <- rgamma(1, shape = alpha_gamma[i] * q,
rate = beta_gamma)
}
}
}
# collect data
data <- list(
count = count,
count_type = count_type
)
# initial values
inits <- list()
inits[[1]] <- list(
alpha = mu,
beta = rep(1, length(mu)),
q = q
)
names(inits[[1]]) <- c("alpha", "beta", "q")
# run model
fit <- suppressWarnings({
traditional_model(data = data, q = TRUE, family = "gamma",
n_chain = 1, multicore = FALSE, seed = 10,
initial_values = inits, n_warmup = 25, n_iter = 100)
})
# get output params
output_params <- rownames(as.data.frame(joint_summarize(fit$model)))
# test expectation
expect_true(all(c("q[1]") %in% output_params))
# detection_calculate and detection_plot
out <- detection_calculate(fit$model, mu = seq(from = 0.1, to = 1, by = 0.1))
# test dimensions
expect_true(all(dim(out) == c(10, 3)))
# test names
expect_true(all(names(as.data.frame(out)) == c("mu", "n_traditional_1",
"n_traditional_2")))
# test numeric
expect_true(all(is.numeric(out[, 1]),
is.numeric(out[, 2]),
is.numeric(out[, 3])), TRUE)
# test plot
out_plot <- detection_plot(fit$model, mu_min = 0.1,
mu_max = 1)
# fit models
fit_q1 <- joint_model(data = green_crab_data, family = "negbin",
p10_priors = c(1, 20), q = TRUE, multicore = FALSE,
n_chain = 1, n_iter = 1000)
fit_q2 <- joint_model(data = green_crab_data, family = "negbin",
p10_priors = c(1, 50), q = TRUE, multicore = FALSE,
n_chain = 1, n_iter = 1000)
# run select
select <- joint_select(model_fits = list(fit_q1$model, fit_q2$model))
# check dimensions
expect_equal(dim(select)[1], 2)
# check numeric
expect_equal(is.numeric(select[, 1]), TRUE)
expect_equal(is.numeric(select[, 2]), TRUE)
roxygen2::roxygenise()
roxygen2::roxygenise()
lint_package(path = ".")
library(lintr)
lint_package(path = ".")
lint_package(path = ".")
roxygen2::roxygenise()
roxygen2::roxygenise()
lint_package(path = ".")
utils::globalVariables("test")
lint_package(path = ".")
lint_package(path = ".")
initial_values <- NULL
q_names <- c('1')
count_all <- as.data.frame(matrix(rnorm(25) , nrow = 5) )
count_all
colnames(count_all) <- c('L_ind','1','2','3','4')
n_chain <- 4
#helper function
#traditional model, catchability coefficient
init_list <- list()
if (all(!is.null(initial_values))) {
for (i in 1:n_chain) {
init_list[[i]] <- list(
mu = if ("mu" %in% names(initial_values[[i]])) {
initial_values[[i]]$mu
} else {
stats::runif(length(unique(count_all$L_ind)), 0.01, 5)
},
q = if ("q" %in% names(initial_values[[i]])) {
as.data.frame(initial_values[[i]]$q)
} else {
as.data.frame(stats::runif(length(q_names), 0.01, 1))
}
)
}
} else {
for (i in 1:n_chain) {
init_list[[i]] <- list(
mu = stats::runif(length(unique(count_all$L_ind)), 0.01, 5),
q = as.data.frame(stats::runif(length(q_names), 0.01, 1))
)
}
}
lint_package(path = ".")
initial_values <- NULL
i <- 1
"alpha" %in% names(initial_values[[i]])
!is.null(initial_values)
length(initial_values) != n_chain
lint_package(path = ".")
lint_package(path = ".")
roxygen2::roxygenise()
lint_package(path = ".")
getwd()
test <- rstan::stan_model('inst/stan/joint_continuous.stan')
test <- rstan::stan_model('inst/stan/joint_count.stan')
test <- rstan::stan_model('inst/stan/traditional_count.stan')
test <- rstan::stan_model('inst/stan/traditional_continuous.stan')
devtools::install()
lint('inst/stan/joint_continuous.stan')
lint('inst/stan/joint_count.stan')
use_lintr()
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
read.dcf('.lintr')
read.dcf('inst/stan/.lintr')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
read.dcf('inst/stan/.lintr')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint_dir(path = 'inst/stan')
lint_dir(path = 'inst/stan')
lint('inst/stan/traditional_count.stan')
lint('inst/stan/traditional_count.stan')
lint('inst/stan/traditional_continuous.stan')
lint('inst/stan/joint_continuous.stan')
lint('inst/stan/joint_count.stan')
lint('inst/stan/joint_count.stan')
lint_package()
