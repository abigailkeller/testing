}
## #9. qPCR.N must be an integer
#' @srrstats {G5.8,G5.8b} Pre-processing routines to check for data of
#'   unsupported type
if(qPCR.N %% 1 != 0) {
errMsg <- "qPCR.N should be an integer."
stop(errMsg)
}
}
# test plot
out_plot <- detectionPlot(fit$model, mu.min = 0.1,
mu.max = 1)
# test plot
out_plot <- detectionPlot(out, mu.min = 0.1,
mu.max = 1)
# test plot type
expect_equal(mode(out_plot),'list')
# test data in plot
expect_equal(all(is.numeric(out_plot$data$mu),
is.character(out_plot$data$survey_type),
is.numeric(out_plot$data$value)), TRUE)
## 2.
# model includes 'p10','beta','q'
# constants
nsite <- 20
nobs_count <- 100
nobs_pcr <- 8
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
beta <- 0.5
log_p10 <- -4.5
q <- 2
# traditional type
count_type <- cbind(matrix(1, nrow = nsite, ncol = nobs_count/2),
matrix(2, nrow = nsite, ncol = nobs_count/2))
# count
count <- matrix(NA, nrow = nsite, ncol = nobs_count)
for(i in 1:nsite){
for(j in 1:nobs_count){
if(count_type[i,j]==1){
count[i,j] <- rpois(1, mu[i])
} else {
count[i,j] <- rpois(1, mu[i]*q)
}
}
}
# p11 (probability of true positive eDNA detection) and p (probability
# of eDNA detection)
p11 <- rep(NA,nsite)
p <- rep(NA,nsite)
for (i in 1:nsite){
p11[i] <- mu[i] / (mu[i] + exp(beta))
p[i] <- min(p11[i] + exp(log_p10),1)
}
# qPCR.N (# qPCR observations)
qPCR.N <- matrix(NA, nrow = nsite, ncol = nobs_pcr)
for(i in 1:nsite){
qPCR.N[i,] <- rep(3,nobs_pcr)
}
# qPCR.K (# positive qPCR detections)
qPCR.K <- matrix(NA, nrow = nsite, ncol = nobs_pcr)
for (i in 1:nsite){
qPCR.K[i,] <- rbinom(nobs_pcr, qPCR.N[i,], rep(p[i], nobs_pcr))
}
# collect data
data <- list(
qPCR.N = qPCR.N,
qPCR.K = qPCR.K,
count = count,
count.type = count_type
)
# initial values
inits <- list()
inits[[1]] <- list(
mu = mu,
p10 = exp(log_p10),
alpha = beta,
q = q
)
names(inits[[1]]) <- c('mu','p10','alpha','q')
cov =  NULL
family = 'poisson'
p10priors = c(1,20)
q = TRUE
phipriors = NULL
multicore = FALSE
initial_values = inits
n.chain = 1
n.iter.burn = 100
n.iter.sample = 75
thin = 1
adapt_delta = 0.9
verbose = TRUE
seed = NULL
moddat <- get_model_data(data,cov,family,p10priors,q,phipriors,
multicore,initial_values,n.chain,n.iter.burn,
n.iter.sample,thin,adapt_delta,verbose,seed)
# moddat <- get_model_data_trad(data, family,q,phipriors,multicore,
#                                           initial_values,n.chain,n.iter.burn,
#                                           n.iter.sample,thin,adapt_delta,
#                                           verbose, seed)
model_data <- moddat[[1]]
inits <- moddat[[2]]
# run model
out <- rstan::sampling(
model_count,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
# get output params
output_params <- rownames(as.data.frame(jointSummarize(out)))
# test expectation
expect_true(all(c('p10','q[1]','alpha[1]') %in% output_params))
# test expectation
expect_true(out@par_dims$phi == 0)
# detectionCalculate and detectionPlot
out1 <- detectionCalculate(out, mu = seq(from = 0.1, to = 1, by = 0.1))
out1
# test dimensions
expect_true(all(dim(out1) == c(10,4)))
# test names
expect_true(all(names(as.data.frame(out1))==c('mu','n_traditional_1',
'n_traditional_2','n_eDNA')))
# test numeric
expect_true(all(is.numeric(out1[,1]),
is.numeric(out1[,2]),
is.numeric(out1[,3]),
is.numeric(out1[,4])),TRUE)
# constants
nsite <- 50
nobs_count <- 100
nobs_pcr <- 8
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
beta <- 0.5
log_p10 <- -4.5
phi <- 1.2
# count
count <- matrix(NA, nrow = nsite, ncol = nobs_count)
for(i in 1:nsite){
count[i,] <- rnbinom(n = nobs_count, mu = mu[i], size = phi)
}
# p11 (probability of true positive eDNA detection) and p (probability
# of eDNA detection)
p11 <- rep(NA,nsite)
p <- rep(NA,nsite)
for (i in 1:nsite){
p11[i] <- mu[i] / (mu[i] + exp(beta))
p[i] <- min(p11[i] + exp(log_p10),1)
}
# qPCR.N (# qPCR observations)
qPCR.N <- matrix(NA, nrow = nsite, ncol = nobs_pcr)
for(i in 1:nsite){
qPCR.N[i,] <- rep(3,nobs_pcr)
}
# qPCR.K (# positive qPCR detections)
qPCR.K <- matrix(NA, nrow = nsite, ncol = nobs_pcr)
for (i in 1:nsite){
qPCR.K[i,] <- rbinom(nobs_pcr, qPCR.N[i,], rep(p[i],nobs_pcr))
}
# collect data
data <- list(
qPCR.N = qPCR.N,
qPCR.K = qPCR.K,
count = count
)
# initial values
inits <- list()
inits[[1]] <- list(
mu = mu,
p10 = exp(log_p10),
alpha = beta,
phi = phi
)
names(inits[[1]]) <- c('mu','p10','alpha','phi')
cov =  NULL
family = 'negbin'
p10priors = c(1,20)
q = FALSE
phipriors = NULL
multicore = FALSE
initial_values = inits
n.chain = 1
n.iter.burn = 100
n.iter.sample = 75
thin = 1
adapt_delta = 0.9
verbose = TRUE
seed = NULL
moddat <- get_model_data(data,cov,family,p10priors,q,phipriors,
multicore,initial_values,n.chain,n.iter.burn,
n.iter.sample,thin,adapt_delta,verbose,seed)
# moddat <- get_model_data_trad(data, family,q,phipriors,multicore,
#                                           initial_values,n.chain,n.iter.burn,
#                                           n.iter.sample,thin,adapt_delta,
#                                           verbose, seed)
model_data <- moddat[[1]]
inits <- moddat[[2]]
# run model
out <- rstan::sampling(
model_count,
data = model_data,
cores = 1,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = n.chain,
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
# get output params
output_params <- rownames(as.data.frame(jointSummarize(out)))
# test expectation
expect_true(all(c('p10','phi','alpha[1]') %in% output_params))
# detectionCalculate and detectionPlot
out1 <- detectionCalculate(out, mu = seq(from = 0.1, to = 1, by = 0.1))
modelfit <- out
mu = seq(from = 0.1, to = 1, by = 0.1)
cov.val = NULL
probability = 0.9
qPCR.N = 3
# input checks
#' @srrstats {G2.1} Types of inputs are checked/asserted using this helper
#'   function
detectionCalculate_input_checks(modelfit, mu, cov.val, probability, qPCR.N)
# get n traditional samples
if(isCatch(modelfit@model_pars)){
ntrad_out <- get_ntrad_q(modelfit@model_pars, modelfit, mu, probability)
} else {
ntrad_out <- get_ntrad(modelfit@model_pars, modelfit, mu, probability)
}
isCatch(modelfit@model_pars)
modelfit@par_dims$q>0
detectionCalculate <- function(modelfit, mu, cov.val = NULL, probability = 0.9,
qPCR.N = 3){
# input checks
#' @srrstats {G2.1} Types of inputs are checked/asserted using this helper
#'   function
detectionCalculate_input_checks(modelfit, mu, cov.val, probability, qPCR.N)
if (!requireNamespace("rstan", quietly = TRUE)){
stop ("The 'rstan' package is not installed.", call. = FALSE)
}
## check to see if there are any divergent transitions
#' @srrstats {BS4.5} Warning message if the input model fit has divergence
#'   transitions
if(sum(lapply(rstan::get_sampler_params(modelfit,inc_warmup = FALSE),
div_check)[[1]]) > 0){
sum <- sum(lapply(rstan::get_sampler_params(modelfit,inc_warmup = FALSE),
div_check)[[1]])
warning_msg <- paste0('Warning: There are ',sum,
' divergent transitions in your model fit. ')
warning(warning_msg)
}
# get n traditional samples
if(isCatch(modelfit)){
ntrad_out <- get_ntrad_q(modelfit@model_pars, modelfit, mu, probability)
} else {
ntrad_out <- get_ntrad(modelfit@model_pars, modelfit, mu, probability)
}
# get n dna samples
if(isJoint(modelfit@model_pars)){
ndna_out <- get_ndna(modelfit@model_pars, modelfit, mu, qPCR.N,
probability, cov.val)
}
# combine into one df - joint model
if(isJoint(modelfit@model_pars)){
if(isCatch(modelfit)){
out <- cbind(mu,ntrad_out,ndna_out)
#rename columns
trad_names <- c()
for(i in 1:modelfit@par_dims$q){
trad_names <- c(trad_names,paste('n_traditional_',i+1,sep = ''))
}
colnames(out) <- c('mu','n_traditional_1',trad_names,'n_eDNA')
} else {
out <- cbind(mu,ntrad_out,ndna_out)
colnames(out) <- c('mu','n_traditional','n_eDNA')
}
}
# combine into one df - traditional model
if(!isJoint(modelfit@model_pars)){
if(isCatch(modelfit)){
out <- cbind(mu,ntrad_out)
#rename columns
for(i in 1:modelfit@par_dims$q){
trad_names <- paste('n_traditional_',i+1,sep = '')
}
colnames(out) <- c('mu','n_traditional_1',trad_names)
} else {
out <- cbind(mu,ntrad_out)
colnames(out) <- c('mu','n_traditional')
}
}
return(out)
}
# functions to check model type
isJoint <- function(pars){
out <- ifelse('p10' %in% pars,TRUE,FALSE)
return(out)
}
isCatch <- function(modelfit){
out <- ifelse(modelfit@par_dims$q>0,TRUE,FALSE)
return(out)
}
isNegbin <- function(modelfit){
out <- ifelse(modelfit@par_dims$phi == 1,
TRUE,FALSE)
return(out)
}
# function to get n traditional samples
get_ntrad <- function(pars, modelfit, mu, probability){
# number of traditional survey effort
ntrad_out <- vector(length = length(mu))
for(i in seq_along(mu)){
# number of traditional survey replicates
ntrad <- seq(from = 0, to = 50000, by = 1)
# P(X = 0 | mu) in one traditional survey trial
if(isNegbin(modelfit)){
phi <- stats::median(unlist(rstan::extract(modelfit, pars = 'phi[1]')))
pr <- stats::pnbinom(q = 0, mu = mu[i], size = phi)
} else {
pr <- stats::ppois(q = 0, lambda = mu[i])
}
# dnbinom: x = failed events; size = successful events
# probability of catching >0 animals based on ntrad
prob <- 1 - stats::dnbinom(x = 0, size = ntrad, prob = pr)
# find value
value <- match(min(prob[prob >= probability]), prob)
ntrad_out[i] <- ntrad[value]
}
return(ntrad_out)
}
# function to get n traditional samples -- catchability coefficient
get_ntrad_q <- function(pars, modelfit, mu, probability){
# get catch coefficients
# create empty q list
q_list <- list()
# fill in q list
for(i in 1:modelfit@par_dims$q){
name <- paste('q',i,sep = '')
q_list[[name]] <- stats::median(rstan::extract(modelfit,
pars = 'q')$q[,i])
}
q_list <- c(1,unlist(q_list))
# number of traditional survey effort
ntrad_out <- matrix(NA,nrow = length(mu),ncol = length(q_list))
for(j in seq_along(q_list)){
for(i in seq_along(mu)){
# number of traditional survey replicates
ntrad <- seq(from = 0, to = 50000, by = 1)
# P(X = 0 | mu) in one traditional survey trial
if(isNegbin(modelfit)){
phi <- stats::median(unlist(rstan::extract(modelfit, pars = 'phi[1]')))
pr <- stats::pnbinom(q = 0, mu = q_list[j]*mu[i], size = phi)
} else {
pr <- stats::ppois(q = 0, lambda = q_list[j]*mu[i])
}
# dnbinom: x = failed events; size = successful events
# probability of catching >0 animals based on ntrad
prob <- 1 - stats::dnbinom(x = 0, size = ntrad, prob = pr)
# find value
value <- match(min(prob[prob >= probability]), prob)
ntrad_out[i,j] <- ntrad[value]
}
}
return(ntrad_out)
}
# function to get n eDNA samples
get_ndna <- function(pars, modelfit, mu, qPCR.N, probability, cov.val){
# get beta
alpha <- apply(rstan::extract(modelfit, pars = 'alpha')$alpha,2,'median')
beta <- alpha %*% c(1,cov.val)
# create output
ndna_out <- vector(length = length(mu))
for(i in seq_along(mu)){
# number of eDNA samples
ndna <- seq(from = 0, to = 50000, by = 1)
p11 <- mu[i]/(mu[i]+exp(beta))
# P(at least one detection|mu) out of total bottles/PCR replicates
prob <- 1 - stats::dbinom(x = 0, size = ndna*qPCR.N, prob = p11)
# find value
value <- match(min(prob[prob >= probability]), prob)
ndna_out[i] <- ndna[value]
}
return(ndna_out)
}
#function to check for divergent transitions
div_check <- function(x){
divergent <- sum(x[,'divergent__'])
return(divergent)
}
# function for input checks
#' @srrstats {G5.2a} Pre-processing routines to check inputs have unique
#'   messages
detectionCalculate_input_checks <- function(modelfit, mu, cov.val,
probability, qPCR.N){
## #1. make sure model fit is of class stanfit
#' @srrstats {G2.8} Makes sure input of sub-function is of class 'stanfit'
#'   (i.e., output of jointModel())
if(!is(modelfit,'stanfit')) {
errMsg <- "modelfit must be of class 'stanfit'."
stop(errMsg)
}
## #2. make sure mu is a numeric vector
#' @srrstats {G5.8,G5.8b} Pre-processing routines to check for data of
#'   unsupported type
if(!any(is.numeric(mu)) | any(mu <= 0)) {
errMsg <- "mu must be a numeric vector of positive values"
stop(errMsg)
}
## #3. make sure probability is a numeric value between 0 and 1
#' @srrstats {G2.0,G2.2} Assertion on length of input, prohibit multivariate
#'   input to parameters expected to be univariate
if(!is.numeric(probability) | length(probability)>1 | any(probability < 0) |
any(probability > 1)) {
errMsg <- "probability must be a numeric value between 0 and 1"
stop(errMsg)
}
## #4. cov.val is numeric, if provided
#' @srrstats {G5.8,G5.8b} Pre-processing routines to check for data of
#'   unsupported type
if(all(!is.null(cov.val)) && !is.numeric(cov.val)) {
errMsg <- "cov.val must be a numeric vector"
stop(errMsg)
}
## #5. Only include input cov.val if covariates are included in model
if(all(!is.null(cov.val)) &&
modelfit@par_dims$alpha == 1) {
errMsg <- paste0("cov.val must be NULL if the model does not ",
"contain site-level covariates.")
stop(errMsg)
}
## #6. Input cov.val is the same length as the number of estimated covariates.
#' @srrstats {G2.0} Assertion on length of input
if(all(!is.null(cov.val)) &&
length(cov.val) != (modelfit@par_dims$alpha-1)) {
errMsg <- paste0("cov.val must be of the same length as the number of ",
"non-intercept site-level coefficients in the model.")
stop(errMsg)
}
## #7. If covariates are in model, cov.val must be provided
if(modelfit@par_dims$alpha > 1 &&
'p10' %in% modelfit@model_pars && all(is.null(cov.val))) {
errMsg <- paste0("cov.val must be provided if the model contains ",
"site-level covariates.")
stop(errMsg)
}
## #8. qPCR.N must be an integer
#' @srrstats {G5.8,G5.8b} Pre-processing routines to check for data of
#'   unsupported type
if(qPCR.N %% 1 != 0) {
errMsg <- "qPCR.N should be an integer."
stop(errMsg)
}
}
# detectionCalculate and detectionPlot
out1 <- detectionCalculate(out, mu = seq(from = 0.1, to = 1, by = 0.1))
out1
# test dimensions
expect_true(all(dim(out1) == c(10,3)))
# test names
expect_true(all(names(as.data.frame(out1))==c('mu','n_traditional','n_eDNA')))
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
model_count <- rstan::stan_model('inst/stan/joint_count.stan')
